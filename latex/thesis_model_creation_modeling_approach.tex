\section{Modeling approach}
Our approach in creating the PVS model from Fiasco's C++ source code is explained in detail in this chapter, along with a look at the basics of our PVS model. At the moment, there is no converter which can completely convert the Fiasco C++ source code to our proof language of choice, PVS. We are therefore limited to creating a model of the code. When using a model as the basis for proofs, the obvious disadvantage is that we cannot claim to have proven anything about the code; strictly speaking those proofs only apply to the model and not to the code being modelled. However, if one trusts the model to be an accurate representation of the code (albeit probably on a higher level), any proof claims of the model would also apply to the code. \emptyline

There are two ways to create a model of source code: create a one-on-one translation or create a higher-level model (which abstracts away some of the details in the code). The main advantage of the first method is that it can help increase confidence that the model is an accurate representation of the source code. This is due to the fact that each line in the source code can be directly linked to a part of the model. The disadvantage is that such a detailed model can quickly become very large, which makes proofs more difficult to establish and can also make the creation of the model a tedious process. The second method looks at the source code at a higher level, focusing more on \textit{what} the source code does than \textit{how}. The disadvantage here is that one has to have a good understanding of what the system does, which can be more difficult than it sounds. One of its advantages is that the model can choose to focus on a specific part of the source code, leaving out uninteresting or irrelevant parts. Therefore, the model will be more compact, making it easier to comprehend and proofs probably smaller.