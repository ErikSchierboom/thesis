\hypertarget{related_work}{\section{Related work}}
Although the Fiasco kernel is in continuous development, there already has been some effort in formally verifying it. In this respect, Fiasco also serves as a test project to study the feasibility of a verified microkernel. The attempts to verify the Fiasco kernel belong to the VFiasco project \cite{hohmuth03applying}. Besides describing why they want to verify the Fiasco kernel, Hohmuth and Tews also describe why they decided to verify the C++ Fiasco source and not re-implement the kernel in a 'safe' programming language. It is interesting to see that the approaches taken to verify parts of Fiasco differ on many parts.

\subsection{Verifying memory management in Fiasco}
One of the first attempts to verify the Fiasco kernel focused on Fiasco's memory management \cite{tews00case}. The approach taken by Tews was to create a co-algebraic model of memory management in Fiasco in the CCSL language \cite{hensel98reasoning}. After Fiasco's memory management was modelled in CCSL, this model was compiled to a PVS specification in which properties of the co-algebraic model were proven. The approach taken was successful in formally verifying several properties of Fiasco's memory management. There were however two problems with the approach taken. First of all, CCSL lacks support for imperative programming, which lessens its applicability to real-world situations as imperative programming is widely used. Therefore, creating a model of Fiasco (which was written in an imperative language) was not as intuitive in CCSL as it could be. The second problem was the creation of the CCSL model from the Fiasco source, which had to be done by hand. So far, no conversion can be made from C++ to CCSL, which is mainly due to the complexity of C++. This leaves one no choice but to convert the source code by hand, which can be a daunting task for large programs. A manual conversion also has the disadvantage that, strictly speaking, the properties proven only apply to the CCSL model and not to the actual C++ source. This is because one cannot guarantee that the hand-made C++ to CCSL conversion retains the source code's semantics. As said, defining a formal semantics of C++ is extremely hard due to its complexity. According to the author, this leaves us with two solutions: only verify source code in a language with well-defined semantics or use a well-behaved subset of C++ with a clear semantics.

\subsection{Developing a C++ semantics compiler}
In line with the conclusions of the work described above, development of a C++ semantics compiler was attempted by Matthias Daum in \cite{daum03development}. His compiler uses the earlier work by Hohmuth and Tews in describing the semantics of C++ data types \cite{hohmuth03semantics}. Although the developed C++ compiler partly met its design goals (such as flexibility and architecture independence), there was still a reasonable number of unsupported C++ features. The list of unsupported features included \emph{function pointers}, \emph{enumerations}, \emph{dynamic casts}, \emph{recursive functions} and \emph{access specifiers}. The author deemed some of these features unneccessary because Fiasco didn't use them (such as function pointers and recursive functions) and declared others as rare and usually avoidable (for example unions and bit-fields). The proposed testcase for the compiler was to compile the page-fault handler in Fiasco. Unfortunately, the C++ compiler failed to compile even the relatively small page-fault handler. The inability to compile the page-fault handler indicated that the compiler was not yet ready to be used extensively in Fiasco.

\subsection{Verifying IPC in Fiasco}
Memory management in Fiasco has not been the only component which has been subject to formal verification. The thesis by Endrawaty describes his attempt to formally verify (a part of) inter-process communication in Fiasco using model checking \cite{endrawaty05veri}. His approach is based on creating a model in the Promela language which could then be verified in SPIN \cite{havelund00spin}. Promela is a non-deterministic language derived from Dijkstra's guarded commands \cite{dijkstra75guarded}. Verification in SPIN is basically done by extensively checking the whole state space. To verify a property, the system checks if the property holds in every possible state. This brute-force\footnote{A brute-force method implies that it does not use any intelligence to limit the state space, it just tries all possibilities.} method has some disadvantages, most notably poor performance and high memory usage because of the extensive state space.\emptyline

To simplify the creation of the IPC model (and to combat the aforementioned state space problems), the author abstracted away a lot of details and focused on the short IPC path only. Some of the features that were not modelled include \emph{page-faults} and \emph{interrupts}. Furthermore, the author assumed that the timeout was always equal to zero and represented the data copying process with a single boolean value indicating the success of the data copying itself. Even though the model itself was not that big and abstracted away a lot of details, state space problems did occur. Unfortunately, the properties proven by Endrawaty do not exceed that of simple state checks.\emptyline

Just as in the memory management verification, one of the biggest problems is in translating the C++ source to the language in which the verification will be done (in this case Promela). At first the author tried to create a model by looking at the functionality IPC offers, but later on he just continued with translating the C++ source line-by-line to Promela (albeit in an iterative way). The author concludes by recommending to look into possible optimizations of the model, after which more features could be added (for example by removing some of the abstractions), though he does not give any indication on how to the model might be optimized.

\subsection{Improved IPC path}
After signalling that there were several performance problems with IPC in Fiasco, Ren\'e Reusner set out to create a new (long) IPC path that solved (several of) these problems \cite{reusner05impl}. The author chose to optimize the IPC calls most frequently used, namely the \emph{call}- and \emph{reply-wait} calls. As mentioned before, both calls involve a send- and receive operation and switch atomically between these two modes. In the old IPC version almost every part of the call- and wait calls was fully preemptable. In the improved IPC path, most of those parts were \textit{not} preemptable, which saved synchronization costs and thus improved performance. To still be able to guarantee real-time response times, interrupt points were inserted at specific points in which IPC could be interrupted.\emptyline

The implemented IPC path offered significant improvements over the old IPC path. However, some future work still remained. For one, when sending an IPC message the priority of the sender is always used; it would be more correct to use the maximum of the sender- \emph{and} receiver's priority. Furthermore, the problem of priority inversion still existed, although a reference to a possible solution is given.

\subsection{L4.verified}
Although not directly related to Fiasco, the work in the L4.verified is similar enough to include it here. The goal of the L4.verified project is to provide a mathematical proof of the L4 microkernel specification; the required formal specification was created using the B method \cite{sorensen01towards} and is described in \cite{kolanski06formalising}. Although this approach was fairly successful, the project still changed directions. Work was continued on an expanded L4 specification, which was specifically aimed at developing secure embedded systems. This specification, named seL4 (secure embedded L4), differed from L4 mainly in its use of capabilities, which are the sole providers of access to kernel services. The goal of the seL4 project was to create a formally verified implementation of the seL4 microkernel specification.\emptyline

The development of the seL4 microkernel was based on incrementally developing a prototype in the Haskell functional language. To test the prototype conventionally, test applications were developed that ran on the seL4 prototype and simulated regular use thereof. Through these tests and further incremental improvement, the prototype ended up as a complete kernel implementation. At this point, verification of the Haskell kernel implementation was attempted. For this purpose, the Haskell specification was converted to a specification in the Isabelle/HOL proof system \cite{nipkow02isabelle}, which allowed it to be formally verified. The conversion was done manually, which was considered to be faster than developing an application for automatic conversion. After verification of the prototype was successful, the Haskell code was converted to C code for performance purposes. The aim is to also verify this C implementation, for which a formal model of the C language was developed \cite{tuch07types}.\emptyline

Currently, the state of the project is that the seL4 kernel is precisely specified in both Haskell and Isabelle/HOL. Around 90 percent of this specification has been verified and its implementation in C is nearing completion. There has not been any large-scale verification attempt of the C implementation, but confidence exists in its feasibility as a case-study has shown that the L4 kernel memory allocator could be verified.